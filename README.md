# Hands on with Sat4j @ SAT+SMT 2019

Here are the files needed to experiment a few features of Sat4j.

## Researchers and seats

Can we sit m researchers on m-1 seats?

More precisely, we consider that

+ Each researcher should have a seat
+ Each seat cannot host more than a researcher

### CNF encoding

CNF encoding has to be done using the [Dimacs format](http://archive.dimacs.rutgers.edu/pub/challenge/satisfiability/doc/).

Each variable is represented by a number.
Each literal is represented by a signed number.
A clause is represented by a sequence of signed integer terminated by 0.

$x_1 \lor x_2 \lor \lnot x_3$ is represented in Dimacs by
`1 2 -3 0`.

It is also mandatory to provide in the header of the file the
number of variables and the number of clauses.

`p cnf <nbvars> <nbclauses>`

To represent the simple formula $(x_1 \lor x_2 \lor \lnot x_3) \land (\lnot x_1 \lor x_2) \land (x_2 \lor x_3) \land \lnot x_2$ with 3 variables and 4 clauses, we can use the following Dimacs file:

```
p cnf 3 4
1 2 -3 0
-1 2 0
2 3 0
-2
```

Such files are not meant to be generated by hand, but generated using a script.

See this [python's script](sittingresearchers.py) to generate the CNF in Dimacs format for the researchers and seats problem.

To generate some instances of the problem for various m,
we can use the script that way:

```shell
$ ./sittingresearchers.py >sitting4.cnf
$ ./sittingresearchers.py 10 >sitting10.cnf
$ ./sittingresearchers.py 20 >sitting20.cnf
```

Those formulas are tiny for current SAT solvers:

```shell
$head -1 sitting*.cnf
==> sitting10.cnf <==
p cnf 90 415

==> sitting20.cnf <==
p cnf 380 3630

==> sitting4.cnf <==
p cnf 12 22
```

However, the last one is already out of reach for modern SAT solvers without specific counting capabilities.

To run Sat4j on those problems:

```shell
$ java -jar org.sat4j.core.jar sitting4.cnf
$ java -jar org.sat4j.core.jar sitting10.cnf
```

### CNF encoding using the opb format

The same encoding can be provided to PB solvers. 
Each clause is simply translated to the corresponding
PB constraint, without coefficient, and a threshold of 1.

The following [Python's script](sittingresearcherscnfopb.py) does this encoding for you.

```shell
$ ./sittingresearcherscnfopb.py >sitting4cnf.opb
$ ./sittingresearcherscnfopb.py 10 >sitting10cnf.opb
$ ./sittingresearcherscnfopb.py 20 >sitting20cnf.opb
```

To run Sat4j on those problems:

```shell
$ java -jar sat4j-pb.jar sitting4cnf.opb
$ java -jar sat4j-pb.jar sitting10cnf.opb
$ java -jar sat4j-pb.jar CuttingPlanes sitting20cnf.opb
```

You can check that CuttingPlanes proof system as implemented
in Sat4j (Generalized Resolution) does not help in this case.

### Pseudo-Boolean encoding (with PB constraints)

The pseudo-Boolean encoding can be done using the [PB Evaluation format](http://www.cril.univ-artois.fr/PB16/format.pdf).

It is similar in spirit with the Dimacs format.

The header has to provide the number of variables and the constraints found in the file.

A variable is represented by `xI` where `I` is an integer.

Sat4j supports the use of literals, using `~xI` notation. This is useful for representing clauses in the OPB format.

Else one has to use `$\lnot x_1 = 1 - x_1$` in the OPB context.

A PB constraint has signed coefficients in front of the
variables (or literals) in the LHS.

The competition requires the inequality to be `>=`, but 
Sat4j supports also `<=` and `=`.

The threshold of the constraint is a signed integer.

The constraint is terminated by `;`.

So $x_1 \lor x_2 \lor \lnot x_3$ is represented by the 
PB constraint $x_1 + x_2 + \overline{x_3} \geq 1$.
In OPB format, it will be represented by

`+1 x_1 +1 x_2 +1 ~x_3 >= 1;`

in Sat4j format, or by

`+1 x_1 +1 x_2 -1 x_3 >= 0;`

in the strict evaluation format.

To represent the simple formula $3*x_1 + 2*x_2 + \overline{x_3} \geq 3 \land x_1 + x_2 + x_3 <= 1$, Sat4j can read 
the following opb file:

```
* variables= 3 *constraints= 2
+3 x_1 +2 x_2 +1 ~x_3 >= 3;
+1 x_1 +1 x_2 +1 x_3 <= 1;
```

which is equivalent to the following one in the strict PB evaluation format:

```
* variable= 3 *constraint= 2
+3 x_1 +2 x_2 -1 x_3 >= 2;
-1 x_1 -1 x_2 -1 x_3 >= -1;
```
See this [python's script](sittingresearchersopb.py) to generate the PB constraints in Sat4j PB format for the researchers and seats problem.

To generate some instances of the problem for various m,
we can use the script that way:

```shell
$ ./sittingresearchersopb.py >sitting4.opb
$ ./sittingresearchersopb.py 10 >sitting10.opb
$ ./sittingresearchersopb.py 20 >sitting20.opb
```

Those formulas are tiny for current PB solvers, and much more compact than the CNF encoding.

```shell
$head -1 sitting*.opb
==> sitting10.opb <==
* #variable= 90 #constraint= 19

==> sitting20.opb <==
* #variable= 380 #constraint= 39

==> sitting4.opb <==
* #variable= 12 #constraint= 7
```

To run Sat4j on those problems:

```shell
$ java -jar sat4j-pb.jar sitting4.opb
$ java -jar sat4j-pb.jar sitting10.opb
$ java -jar sat4j-pb.jar CuttingPlanes sitting20.opb
```

By default, the resolution proof system is used. Only the solver using the CuttingPlanes proof system can solve quickly the problem with `m=20`.

### Retrieving cardinality constraints

Sat4j is able to retrieve cardinality constraints semantically from a CNF input.

You can check that it allows the CuttingPlanes solver
to solve quickly the CNF encoding of our problem for `m=20`.

```
$ java -jar sat4j-pb.jar DetectCards sitting20.cnf 
```

When looking at the output of Sat4j, one can see the
3610 clauses have been replaced by 19 cardinality constraints.

```
c #constraints  20
c constraints type 
c org.sat4j.pb.constraints.pb.OriginalHTClausePB => 20
c 20 constraints processed.
c launching cardinality constraint revelation process
c remaining constraints: 0/3610
c cardinality constraints found (preprocessing): 19
c cardinality search time (preprocessing): 82ms
c found 19 at-most cardinality constraint of degree 1 and size 20
c solver contains 39 constraints
```

## Your turn: sudoku

In the previous exercises, you saw the file format for
CNF or OPB files.

Sudoku is a simple puzzle with an n^2xn^2 grid where all the 
cells should contain one of 1 to n^2 mark, and each row, column, and nxn block should contain all the marks.  

So the following constraints have to be expressed:

- each cell contain exactly one value between 1 and n^2
- each value appears only once in each row
- each value appears only once in each column
- each value appears only once in each nxn block

This puzzle can be expressed with Boolean variables $x_{rcv}$
meaning that in row `r`, column `c`, the value is `v`.

### Case 4x4 (toy one)

Here is an example of filled in 4x4 sudoku:
```
2 3 1 4
1 4 3 2
4 1 2 3
3 2 4 1
```

We need thus 4x4x4 = 64 variables to model this puzzle.

However, it is probably easier to consider using variables
numbered 111 to 444. As such, you will have to declare 444
variables in your OPB file header.

Check that solving the constraints without hints gives you 
a valid 4x4 sudoku.

### Case 9x9 (usual one)

Solve the following sudoku 9x9 problem using either clauses or cardinality constraints:

![](https://blogs.sas.com/content/sastraining/files/2015/01/Figure-1.png)

We will use the following convention to make it easy to
check the constraints and be able to interpret the solution
of the solver.

Each variable will be numbered 111 to 999 with the following meaning: each number rcv will represent as first digit the row, as second digit the column and third digit the value.

So variable 123 will mean: in row 1, column 2, the value is 3.


You will need to add at the end of the file the hints:

CNF:
```
111 0
193 0
237 0
242 0
256 0
274 0
288 0
314 0
349 0
353 0
365 0
396 0
423 0
444 0
458 0
472 0
524 0
531 0
546 0
569 0
573 0
636 0
678 0
689 0
715 0
727 0
738 0
754 0
792 0
843 0
887 0
912 0
995 0
```

OPB:
```
+1 x111 >= 1;
+1 x193 >= 1;
+1 x237 >= 1;
+1 x242 >= 1;
+1 x256 >= 1;
+1 x274 >= 1;
+1 x288 >= 1;
+1 x314 >= 1;
+1 x349 >= 1;
+1 x353 >= 1;
+1 x365 >= 1;
+1 x396 >= 1;
+1 x423 >= 1;
+1 x444 >= 1;
+1 x458 >= 1;
+1 x472 >= 1;
+1 x524 >= 1;
+1 x531 >= 1;
+1 x546 >= 1;
+1 x569 >= 1;
+1 x573 >= 1;
+1 x636 >= 1;
+1 x678 >= 1;
+1 x689 >= 1;
+1 x715 >= 1;
+1 x727 >= 1;
+1 x738 >= 1;
+1 x754 >= 1;
+1 x792 >= 1;
+1 x843 >= 1;
+1 x887 >= 1;
+1 x912 >= 1;
+1 x995 >= 1;
```
Do not forget to add those 33 additional constraints in the header of the file.

Once you have generated your CNF or OPB file, you can
check if you solve that puzzle by decoding the solution
returned by the SAT solver [using that script](decodesudoku.py).

## Playing with PB, PBO and MAXSAT

### Subset sum

[Subset sum](https://en.wikipedia.org/wiki/Subset_sum_problem) is an NP-complete problem.

Some examples of subset sum instances can be found [here](https://people.sc.fsu.edu/~jburkardt/datasets/subset_sum/subset_sum.html).

Is it possible to find a subset of 15,22,14,26,32,9,16,8 
which sums to 53?

Is it possible to find s subset of  267,493,869,961,1000,1153,1246,1598,1766,1922 which sums to 5842?

**Note that such problem can be expressed using a single constraint in Sat4j OPB format.**

### Knapsack problem

Another famous combinatorial problem is the [Knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).

Given some items with a specific weight and specific value,
find the way to pack your items in your luggage with a given
weight capacity to maximize the value of the items.

You can find some instances of this problem [here)(https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html).

> This is no longer a decision problem but an optimization problem.
>
> The OPB format allows you to define an objective function to
> minimize. If you have a maximization problem, you just need
> to minimize the negation of the objective function.
>
> The objective function must be given after the head but before the constraints, using the same format as the LHS of and LPB constraint.
>
> ```
> * #variable= 3 #constraint= 1
> min: +4 x1 +3 x2 +1 x3;
> +1 x1 +1 x2 +1 x3 >= 1;
> ```


Given 10 items with the following weights and values:

```
weights = 23,31,29,44,53,38,63,85,89,82

values  = 92,57,49,68,60,43,67,84,87,72
```

Which items should you choose for a capacity of 165?

### MAXSAT

TBA